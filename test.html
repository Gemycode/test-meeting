<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Video Meeting - Fixed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0e0f13; color: #fff; height: 100vh; overflow: hidden; font-family: system-ui; }
    .container { position: relative; width: 100%; height: 100%; }
    #remote { width: 100%; height: 100%; object-fit: cover; background: #000; }
    #local { position: absolute; bottom: 90px; right: 24px; width: 220px; height: 140px; 
             border-radius: 12px; object-fit: cover; background: #000; 
             border: 1px solid rgba(255,255,255,0.15); }
    .status { position: absolute; top: 20px; left: 20px; padding: 10px 15px; 
              background: rgba(0,0,0,0.7); border-radius: 8px; font-size: 14px; }
    .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
                display: flex; gap: 10px; }
    button { padding: 10px 20px; background: #667eea; color: white; border: none; 
             border-radius: 8px; cursor: pointer; font-size: 14px; }
    button:hover { background: #5568d3; }
    .end { background: #e53935; }
    .end:hover { background: #d32f2f; }
  </style>
</head>
<body>
  <div class="container">
    <video id="remote" autoplay playsinline></video>
    <video id="local" autoplay muted playsinline></video>
    <div class="status" id="status">Initializing...</div>
    <div class="controls">
      <button id="toggleAudio">Mute Audio</button>
      <button id="toggleVideo">Stop Video</button>
      <button class="end" id="endCall">End Call</button>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    // ========================
    // Configuration
    // ========================
    // Security: Validate and sanitize inputs
    const token = localStorage.getItem('jwt_token');
    const bookingId = localStorage.getItem('booking_id');
    
    // Security: Validate token format (basic JWT check)
    if (!token || typeof token !== 'string' || token.split('.').length !== 3) {
      alert('Invalid authentication token');
      localStorage.removeItem('jwt_token');
      localStorage.removeItem('booking_id');
      window.location.href = 'index.html';
      return;
    }
    
    // Security: Validate booking ID format
    if (!bookingId || typeof bookingId !== 'string' || bookingId.length > 100 || !/^[a-zA-Z0-9_-]+$/.test(bookingId)) {
      alert('Invalid booking ID');
      localStorage.removeItem('booking_id');
      window.location.href = 'index.html';
      return;
    }

    const API_URL = window.location.hostname === 'localhost' 
      ? 'http://localhost:5000'
      : 'https://infipeak-api.onrender.com';

    const ICE_CONFIG = {
        iceServers: [
          // STUN servers
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun.relay.metered.ca:80" },
          
          // Metered.ca TURN servers (your credentials)
          {
            urls: "turn:global.relay.metered.ca:80",
            username: "a16d2df4e562ced14c7db172",
            credential: "PNjqNPkm8ZJeirfm",
          },
          {
            urls: "turn:global.relay.metered.ca:80?transport=tcp",
            username: "a16d2df4e562ced14c7db172",
            credential: "PNjqNPkm8ZJeirfm",
          },
          {
            urls: "turn:global.relay.metered.ca:443",
            username: "a16d2df4e562ced14c7db172",
            credential: "PNjqNPkm8ZJeirfm",
          },
          {
            urls: "turns:global.relay.metered.ca:443?transport=tcp",
            username: "a16d2df4e562ced14c7db172",
            credential: "PNjqNPkm8ZJeirfm",
          },
        ],
      iceTransportPolicy: 'all', // all = try TURN + STUN + host
      iceCandidatePoolSize: 10,
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    };

    // ========================
    // WebRTC State
    // ========================
    let pc = null;
    let localStream = null;
    let socket = null;
    let isCaller = false;  // Critical: determines who creates offer
    let pendingIceCandidates = [];
    let makingOffer = false;
    let ignoreOffer = false;

    const localVideo = document.getElementById('local');
    const remoteVideo = document.getElementById('remote');
    const statusEl = document.getElementById('status');

    // ========================
    // Initialize
    // ========================
    async function init() {
      try {
        updateStatus('Getting media devices...');
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });
        localVideo.srcObject = localStream;
        console.log('âœ… Local media acquired');

        updateStatus('Connecting to signaling server...');
        socket = io(API_URL, { auth: { token } });

        socket.on('connect', () => {
          console.log('âœ… Socket connected');
          socket.emit('join-room', { bookingId });
        });

        socket.on('joined', (data) => {
          isCaller = data.isFirst;
          console.log(`âœ… Joined room. Role: ${isCaller ? 'CALLER' : 'CALLEE'}`);
          updateStatus(isCaller ? 'Waiting for peer...' : 'Connecting...');
          createPeerConnection();
        });

        socket.on('peer-joined', () => {
          console.log('âœ… Peer joined');
          updateStatus('Peer connected. Negotiating...');
          // Caller initiates offer when peer joins (with delay to avoid collision)
          if (isCaller) {
            setTimeout(() => {
              negotiate();
            }, 500);
          }
        });

        socket.on('signal', handleSignal);
        
        socket.on('error', (error) => {
          console.error('âŒ Socket error:', error);
          updateStatus('Connection error');
        });

        socket.on('room-full', () => {
          alert('Room full (max 2 peers)');
          updateStatus('Room full');
        });

        socket.on('disconnect', () => {
          console.log('âŒ Socket disconnected');
          updateStatus('Disconnected');
        });

      } catch (err) {
        console.error('âŒ Initialization failed:', err);
        updateStatus('Error: ' + err.message);
        alert('Failed to access camera/microphone: ' + err.message);
      }
    }

    // ========================
    // Peer Connection Setup
    // ========================
    function createPeerConnection() {
      pc = new RTCPeerConnection(ICE_CONFIG);

      // Add local tracks
      localStream.getTracks().forEach(track => {
        track.enabled = true; // Ensure enabled
        pc.addTrack(track, localStream);
        console.log(`âœ… Added ${track.kind} track (enabled: ${track.enabled})`);
      });
      
      console.log(`ðŸ“Š Local stream: ${localStream.getAudioTracks().length} audio, ${localStream.getVideoTracks().length} video`);

      // Handle remote tracks
      pc.ontrack = (e) => {
        console.log(`ðŸ“¡ Remote ${e.track.kind} track received (enabled: ${e.track.enabled}, muted: ${e.track.muted})`);
        if (e.streams[0]) {
          const stream = e.streams[0];
          
          // Set remote video stream
          if (!remoteVideo.srcObject) {
            remoteVideo.srcObject = stream;
            console.log('âœ… Remote stream set');
          } else {
            // Add new tracks to existing stream
            stream.getTracks().forEach(track => {
              const existingStream = remoteVideo.srcObject;
              if (!existingStream.getTracks().find(t => t.id === track.id)) {
                existingStream.addTrack(track);
                console.log(`âž• Added ${track.kind} track to stream`);
              }
            });
          }
          
          // Ensure video is not muted
          remoteVideo.muted = false;
          remoteVideo.volume = 1.0;
          
          // Force play
          remoteVideo.play().catch(err => {
            console.log('Play error:', err);
          });
          
          // Log all tracks
          stream.getTracks().forEach(track => {
            console.log(`  - ${track.kind}: enabled=${track.enabled}, muted=${track.muted}, readyState=${track.readyState}`);
          });
        }
      };

      // ICE candidate handling
      pc.onicecandidate = (e) => {
        if (e.candidate) {
          console.log(`ðŸ“¤ Sending ICE candidate: ${e.candidate.type} (${e.candidate.protocol})`);
          socket.emit('signal', {
            bookingId,
            signal: JSON.stringify({ ice: e.candidate })
          });
        } else {
          console.log('âœ… ICE gathering complete');
        }
      };

      // Connection state monitoring
      pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        updateStatus('Connection: ' + pc.connectionState);
        
        if (pc.connectionState === 'connected') {
          updateStatus('Connected âœ…');
        } else if (pc.connectionState === 'failed') {
          console.log('ðŸ”„ Connection failed, restarting ICE');
          pc.restartIce();
        }
      };

      pc.oniceconnectionstatechange = () => {
        console.log('ICE state:', pc.iceConnectionState);
        if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
          updateStatus('ICE Connected âœ…');
        } else if (pc.iceConnectionState === 'failed') {
          updateStatus('ICE Failed - Retrying...');
          console.log('ðŸ”„ ICE failed, restarting...');
          pc.restartIce();
        } else if (pc.iceConnectionState === 'disconnected') {
          updateStatus('ICE Disconnected - Reconnecting...');
        }
      };

      pc.onsignalingstatechange = () => {
        console.log('Signaling state:', pc.signalingState);
      };

      // Disable automatic negotiation - we control it manually
      pc.onnegotiationneeded = async () => {
        console.log('âš ï¸ Negotiation needed (ignored - manual control)');
        // Disabled: we manually call negotiate() when peer joins
      };
    }

    // ========================
    // Negotiation (Offer/Answer)
    // ========================
    async function negotiate() {
      if (!isCaller || makingOffer) return;
      
      try {
        makingOffer = true;
        console.log('ðŸ“¤ Creating offer...');
        
        // Race condition guard
        if (pc.signalingState !== 'stable') {
          console.log('âš ï¸ Signaling state not stable, aborting offer');
          return;
        }
        
        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        
        await pc.setLocalDescription(offer);
        console.log('ðŸ“¤ Sending offer');
        
        socket.emit('signal', {
          bookingId,
          signal: JSON.stringify({ sdp: pc.localDescription })
        });
      } catch (err) {
        console.error('âŒ Negotiation failed:', err);
      } finally {
        makingOffer = false;
      }
    }

    // ========================
    // Signal Handling
    // ========================
    async function handleSignal(data) {
      try {
        // Security: Validate signal data
        if (!data || typeof data !== 'string') {
          console.warn('âš ï¸ Invalid signal data received');
          return;
        }

        // Security: Limit signal size to prevent DoS
        if (data.length > 10000) {
          console.warn('âš ï¸ Signal too large, ignoring');
          return;
        }

        const msg = JSON.parse(data);
        
        // Security: Validate message structure
        if (!msg || typeof msg !== 'object') {
          console.warn('âš ï¸ Invalid signal message format');
          return;
        }

        // Handle SDP
        if (msg.sdp) {
          const description = new RTCSessionDescription(msg.sdp);
          
          // Perfect Negotiation: Check for offer collision
          const offerCollision = description.type === 'offer' && 
                                 (makingOffer || pc.signalingState !== 'stable');

          ignoreOffer = !isCaller && offerCollision;
          if (ignoreOffer) {
            console.log('âš ï¸ Ignoring colliding offer (Perfect Negotiation)');
            return;
          }

          console.log(`ðŸ“¥ Received ${description.type} (Role: ${isCaller ? 'CALLER' : 'CALLEE'}, State: ${pc.signalingState})`);

          // Validate state before setting remote description
          if (description.type === 'offer') {
            // CALLEE only should handle offers
            if (isCaller) {
              console.warn('âš ï¸ CALLER received offer - ignoring');
              return;
            }
            if (pc.signalingState !== 'stable' && pc.signalingState !== 'have-local-offer') {
              console.warn(`âš ï¸ Cannot set offer in state: ${pc.signalingState}`);
              return;
            }
          } else if (description.type === 'answer') {
            // CALLER only should handle answers
            if (!isCaller) {
              console.warn('âš ï¸ CALLEE received answer - ignoring');
              return;
            }
            if (pc.signalingState !== 'have-local-offer') {
              console.warn(`âš ï¸ Cannot set answer in state: ${pc.signalingState}, expected: have-local-offer`);
              return;
            }
          }

          // Set remote description
          await pc.setRemoteDescription(description);
          console.log(`âœ… Remote ${description.type} set`);

          // If we received an offer, create answer (CALLEE only)
          if (description.type === 'offer') {
            console.log('ðŸ“¤ Creating answer (as CALLEE)...');
            const answer = await pc.createAnswer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            await pc.setLocalDescription(answer);
            
            console.log('ðŸ“¤ Sending answer');
            socket.emit('signal', {
              bookingId,
              signal: JSON.stringify({ sdp: pc.localDescription })
            });
          }

          // Add pending ICE candidates after SDP is set
          if (pendingIceCandidates.length > 0) {
            console.log(`ðŸ“¥ Adding ${pendingIceCandidates.length} pending ICE candidates`);
            for (const candidate of pendingIceCandidates) {
              try {
                await pc.addIceCandidate(candidate);
              } catch (err) {
                console.error('âŒ Failed to add pending ICE:', err);
              }
            }
            pendingIceCandidates = [];
          }
        }

        // Handle ICE candidates
        if (msg.ice) {
          const candidate = new RTCIceCandidate(msg.ice);
          console.log(`ðŸ“¥ Received ICE candidate: ${candidate.type || 'unknown'}`);
          
          if (pc.remoteDescription) {
            try {
              await pc.addIceCandidate(candidate);
              console.log('âœ… ICE candidate added');
            } catch (err) {
              if (!ignoreOffer) {
                console.error('âŒ Failed to add ICE:', err);
              }
            }
          } else {
            // Queue until remote description is set
            console.log('â³ Queuing ICE candidate (no remote description yet)');
            pendingIceCandidates.push(candidate);
          }
        }
      } catch (err) {
        console.error('âŒ Signal handling error:', err);
      }
    }

    // ========================
    // UI Controls
    // ========================
    document.getElementById('toggleAudio').onclick = () => {
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        document.getElementById('toggleAudio').textContent = 
          audioTrack.enabled ? 'Mute Audio' : 'Unmute Audio';
      }
    };

    document.getElementById('toggleVideo').onclick = () => {
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        document.getElementById('toggleVideo').textContent = 
          videoTrack.enabled ? 'Stop Video' : 'Start Video';
      }
    };

    document.getElementById('endCall').onclick = () => {
      if (pc) pc.close();
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      if (socket) socket.disconnect();
      window.location.href = 'index.html';
    };

    function updateStatus(text) {
      statusEl.textContent = text;
    }

    // Start
    init();
  </script>
</body>
</html>
