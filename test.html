<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Video Meeting</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    body {
      background: #0e0f13;
      color: #fff;
      height: 100vh;
      overflow: hidden;
    }

    .meeting-container {
      position: relative;
      width: 100%;
      height: 100%;
      background: #0e0f13;
    }

    /* Main remote video (speaker view) */
    #remote {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
    }

    /* Local self view (picture-in-picture) */
    #local {
      position: absolute;
      bottom: 90px;
      right: 24px;
      width: 220px;
      height: 140px;
      border-radius: 12px;
      object-fit: cover;
      background: #000;
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }

    /* Top bar */
    .top-bar {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 56px;
      display: flex;
      align-items: center;
      padding: 0 20px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
      z-index: 10;
    }

    .meeting-title {
      font-size: 14px;
      font-weight: 500;
      opacity: 0.85;
    }

    .user-badge {
      margin-right: auto;
      font-size: 12px;
      opacity: 0.7;
      padding: 4px 12px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
    }

 
    .controls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 72px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 14px;
      background: linear-gradient(to top, rgba(0,0,0,0.75), transparent);
      z-index: 10;
    }

    .control-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: default;
    }

    .control-btn.end {
      background: #e53935;
      border-color: #e53935;
    }

    .control-btn svg {
      width: 20px;
      height: 20px;
      fill: #fff;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      z-index: 100;
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }

    /* Responsive */
    @media (max-width: 600px) {
      #local {
        width: 140px;
        height: 100px;
        bottom: 80px;
        right: 12px;
      }
    }
  </style>
</head>

<body>
  <div class="meeting-container">

    <!-- Top bar -->
    <div class="top-bar">
      <div class="meeting-title">Secure Video Meeting</div>
      <div class="user-badge" id="userBadge">Loading...</div>
    </div>

    <!-- Videos -->
    <video id="remote" autoplay playsinline controls></video>
    <video id="local" autoplay muted playsinline></video>
    
    <!-- Loading indicator -->
    <div class="loading" id="loading">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„</div>

    <!-- Bottom controls (UI only) -->
    <div class="controls">
      <div class="control-btn">
        <!-- Mic -->
        <svg viewBox="0 0 24 24">
          <path d="M12 14a3 3 0 003-3V5a3 3 0 00-6 0v6a3 3 0 003 3z"/>
        </svg>
      </div>

      <div class="control-btn">
        <!-- Camera -->
        <svg viewBox="0 0 24 24">
          <path d="M17 10.5V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-3.5l4 4v-11l-4 4z"/>
        </svg>
      </div>

      <div class="control-btn end">
        <!-- End call -->
        <svg viewBox="0 0 24 24">
          <path d="M3 10l3-3a15 15 0 0112 0l3 3-3 3-3-3a9 9 0 00-6 0l-3 3-3-3z"/>
        </svg>
      </div>
    </div>
  </div>

  <!-- â— JS LOGIC -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
  // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† localStorage
  const token = localStorage.getItem('jwt_token');
  const bookingId = localStorage.getItem('booking_id');

  if (!token || !bookingId) {
    alert('ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹');
    window.location.href = 'index.html';
  }

  // Auto-detect API URL based on environment
  const API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
    ? 'http://localhost:5000'
    : 'https://infipeak-api.onrender.com';
  
  const socket = io(API_URL, {
    auth: { token: token }
  });

  (async () => {
    const localVideo = document.getElementById('local');
    const remoteVideo = document.getElementById('remote');

    let pc;
    let isInitiator = false;
    let isReady = false;

    let stream = null;
    
    try {
      // Ù…Ø­Ø§ÙˆÙ„Ø© 1: ÙƒØ§Ù…ÙŠØ±Ø§ + Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† Ø¨Ø¬ÙˆØ¯Ø© Ø¹Ø§Ù„ÙŠØ©
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
            facingMode: 'user'
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true
          }
        });
        console.log('Successfully got video + audio');
      } catch (error1) {
        console.warn('Failed to get video+audio, trying video only:', error1);
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© 2: ÙƒØ§Ù…ÙŠØ±Ø§ ÙÙ‚Ø·
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video: true });
          console.log('Successfully got video only');
        } catch (error2) {
          console.warn('Failed to get video, trying audio only:', error2);
          
          // Ù…Ø­Ø§ÙˆÙ„Ø© 3: Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† ÙÙ‚Ø·
          try {
            stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log('Successfully got audio only');
            // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø­Ù„ÙŠ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ ÙƒØ§Ù…ÙŠØ±Ø§
            localVideo.style.display = 'none';
          } catch (error3) {
            console.warn('Failed to get audio, trying basic video:', error3);
            
            // Ù…Ø­Ø§ÙˆÙ„Ø© 4: ÙƒØ§Ù…ÙŠØ±Ø§ Ø¨Ø³ÙŠØ·Ø©
            try {
              stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'user' } 
              });
              console.log('Successfully got basic video');
            } catch (error4) {
              // ÙƒÙ„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª ÙØ´Ù„Øª
              const errorMsg = getErrorMessage(error4);
              throw new Error(errorMsg);
            }
          }
        }
      }
      
      if (stream) {
        localVideo.srcObject = stream;
        localVideo.muted = true; // mute Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø­Ù„ÙŠ (Ø¹Ø§Ø¯Ø©)
        
        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø¬Ù…ÙŠØ¹ tracks Ù…ÙØ¹Ù„Ø©
        stream.getTracks().forEach(track => {
          console.log('Local track:', track.kind, track.enabled, track.readyState);
          track.enabled = true;
        });
        
        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ video trackØŒ Ø£Ø®ÙÙŠ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø­Ù„ÙŠ
        const videoTracks = stream.getVideoTracks();
        if (videoTracks.length === 0) {
          localVideo.style.display = 'none';
          console.log('No video track, hiding local video');
        }
        
        // ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø­Ù„ÙŠ
        localVideo.play().catch(err => {
          console.error('Error playing local video:', err);
        });
      } else {
        throw new Error('ÙØ´Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§/Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†');
      }

      // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª WebRTC Ù…Ø­Ø³Ù†Ø©
      pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ],
        iceCandidatePoolSize: 10
      });

      // Ø¥Ø¶Ø§ÙØ© tracks ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
      if (stream) {
        stream.getTracks().forEach(track => {
          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† track Ù…ÙØ¹Ù„
          track.enabled = true;
          
          // Ø¥Ø¶Ø§ÙØ© track Ù„Ù„Ù€ peer connection
          const sender = pc.addTrack(track, stream);
          console.log('Added track:', track.kind, 'enabled:', track.enabled, 'readyState:', track.readyState);
          
          // Ù…Ø±Ø§Ù‚Ø¨Ø© Ø­Ø§Ù„Ø© track
          track.onended = () => {
            console.log('Local track ended:', track.kind);
          };
          
          track.onmute = () => {
            console.warn('Local track muted:', track.kind);
          };
          
          track.onunmute = () => {
            console.log('Local track unmuted:', track.kind);
          };
        });
        
        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ audio Ùˆ video tracks
        const audioTracks = stream.getAudioTracks();
        const videoTracks = stream.getVideoTracks();
        console.log('Audio tracks:', audioTracks.length, 'Video tracks:', videoTracks.length);
      }

      // Ù…Ø¹Ø§Ù„Ø¬Ø© remote tracks
      pc.ontrack = (e) => {
        console.log('ðŸŽ¥ Received remote track:', e.track.kind, 'from', e.streams.length, 'stream(s)');
        
        if (e.streams && e.streams.length > 0) {
          const remoteStream = e.streams[0];
          
          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ stream Ù…ÙˆØ¬ÙˆØ¯ØŒ Ø£Ø¶Ù Ø§Ù„Ù€ tracks Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¥Ù„ÙŠÙ‡
          if (remoteVideo.srcObject) {
            const existingStream = remoteVideo.srcObject;
            e.streams[0].getTracks().forEach(track => {
              // ØªØ¬Ù†Ø¨ Ø¥Ø¶Ø§ÙØ© tracks Ù…ÙƒØ±Ø±Ø©
              const existingTrack = existingStream.getTracks().find(t => t.id === track.id);
              if (!existingTrack) {
                existingStream.addTrack(track);
                console.log('Added new track to existing stream:', track.kind);
              }
            });
          } else {
            remoteVideo.srcObject = remoteStream;
            console.log('Set new remote stream');
          }
          
          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† audio ØºÙŠØ± muted
          remoteVideo.muted = false;
          remoteVideo.volume = 1.0;
          
          // Ø¥Ø¶Ø§ÙØ© event listeners Ù„Ù„Ù€ stream
          remoteStream.getTracks().forEach(track => {
            console.log('ðŸ“¡ Remote track:', track.kind, 'enabled:', track.enabled, 'readyState:', track.readyState, 'muted:', track.muted);
            
            // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† track Ù…ÙØ¹Ù„
            track.enabled = true;
            
            track.onended = () => {
              console.log('âš ï¸ Remote track ended:', track.kind);
            };
            
            track.onmute = () => {
              console.warn('âš ï¸ Remote track muted:', track.kind);
            };
            
            track.onunmute = () => {
              console.log('âœ… Remote track unmuted:', track.kind);
            };
          });
          
          // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ audio tracks
          const audioTracks = remoteStream.getAudioTracks();
          const videoTracks = remoteStream.getVideoTracks();
          console.log('ðŸ“Š Remote stream - Audio:', audioTracks.length, 'Video:', videoTracks.length);
          
          if (audioTracks.length > 0) {
            console.log('ðŸ”Š Audio track found and enabled');
          } else {
            console.warn('âš ï¸ No audio track in remote stream');
          }
          
          document.getElementById('loading').style.display = 'none';
          console.log('âœ… Remote video stream set successfully');
          
          // ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
          remoteVideo.play().then(() => {
            console.log('â–¶ï¸ Remote video playing');
          }).catch(err => {
            console.error('âŒ Error playing remote video:', err);
          });
        }
      };

      // Ø¥Ø±Ø³Ø§Ù„ ICE candidates
      pc.onicecandidate = (e) => {
        if (e.candidate) {
          console.log('Sending ICE candidate');
          socket.emit('signal', {
            bookingId,
            signal: JSON.stringify({ ice: e.candidate })
          });
        } else {
          console.log('ICE gathering complete');
        }
      };

      // Ù…Ø±Ø§Ù‚Ø¨Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„
      pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        if (pc.connectionState === 'connected') {
          document.getElementById('loading').style.display = 'none';
          console.log('âœ… WebRTC connection established!');
        } else if (pc.connectionState === 'failed') {
          console.error('âŒ WebRTC connection failed');
          document.getElementById('loading').textContent = 'ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„. Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©...';
        }
      };

      // Ù…Ø±Ø§Ù‚Ø¨Ø© ICE connection state
      pc.oniceconnectionstatechange = () => {
        console.log('ICE connection state:', pc.iceConnectionState);
      };

      socket.on('joined', async (data) => {
        console.log('Joined room successfully', data);
        isReady = true;
        isInitiator = data.isFirst;
        
        if (data.isFirst) {
          // Ø¥Ø°Ø§ ÙƒÙ†Ø§ Ø§Ù„Ø£ÙˆÙ„ØŒ Ù†Ù†ØªØ¸Ø± Ø­ØªÙ‰ ÙŠÙ†Ø¶Ù… Ø´Ø®Øµ Ø¢Ø®Ø±
          console.log('Waiting for peer to join...');
        } else {
          // Ø¥Ø°Ø§ ÙƒÙ†Ø§ Ø§Ù„Ø«Ø§Ù†ÙŠØŒ Ù†Ø±Ø³Ù„ offer Ù…Ø¨Ø§Ø´Ø±Ø©
          console.log('Second person joined, creating offer...');
          setTimeout(async () => {
            try {
              const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
              await pc.setLocalDescription(offer);
              console.log('Sending offer');
              socket.emit('signal', {
                bookingId,
                signal: JSON.stringify({ sdp: offer })
              });
            } catch (error) {
              console.error('Error creating offer:', error);
            }
          }, 500);
        }
      });

      socket.on('peer-joined', async () => {
        // Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙ†Ø¶Ù… Ø´Ø®Øµ Ø¢Ø®Ø±ØŒ Ø§Ù„Ø£ÙˆÙ„ ÙŠØ±Ø³Ù„ offer
        if (isInitiator && isReady) {
          console.log('Peer joined, creating offer...');
          setTimeout(async () => {
            try {
              const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
              await pc.setLocalDescription(offer);
              console.log('Sending offer');
              socket.emit('signal', {
                bookingId,
                signal: JSON.stringify({ sdp: offer })
              });
            } catch (error) {
              console.error('Error creating offer:', error);
            }
          }, 500);
        }
      });

      socket.on('room-full', () => {
        alert('Ø§Ù„ØºØ±ÙØ© Ù…Ù…ØªÙ„Ø¦Ø© (Ø´Ø®ØµØ§Ù† ÙÙ‚Ø·)');
      });

      socket.on('signal', async (data) => {
        try {
          const msg = JSON.parse(data);
          console.log('Received signal:', Object.keys(msg));
          
          if (msg.sdp) {
            console.log('Received SDP:', msg.sdp.type);
            
            try {
              // Ø¥Ø¶Ø§ÙØ© SDP description
              await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
              console.log('Remote description set:', msg.sdp.type);
              
            if (msg.sdp.type === 'offer') {
              // Ø¥Ø°Ø§ Ø§Ø³ØªÙ‚Ø¨Ù„Ù†Ø§ offerØŒ Ù†ÙƒÙˆÙ† answer
              console.log('Creating answer...');
              const answer = await pc.createAnswer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
              await pc.setLocalDescription(answer);
              console.log('Sending answer');
              socket.emit('signal', {
                bookingId,
                signal: JSON.stringify({ sdp: answer })
              });
              
              // Ø¥Ø¶Ø§ÙØ© pending ICE candidates Ø¨Ø¹Ø¯ setRemoteDescription
              if (pc.pendingIceCandidates) {
                console.log('Adding pending ICE candidates:', pc.pendingIceCandidates.length);
                for (const candidate of pc.pendingIceCandidates) {
                  try {
                    await pc.addIceCandidate(candidate);
                  } catch (e) {
                    console.error('Error adding pending ICE candidate:', e);
                  }
                }
                pc.pendingIceCandidates = [];
              }
            } else if (msg.sdp.type === 'answer') {
              console.log('Answer received and set');
              
              // Ø¥Ø¶Ø§ÙØ© pending ICE candidates Ø¨Ø¹Ø¯ setRemoteDescription
              if (pc.pendingIceCandidates) {
                console.log('Adding pending ICE candidates:', pc.pendingIceCandidates.length);
                for (const candidate of pc.pendingIceCandidates) {
                  try {
                    await pc.addIceCandidate(candidate);
                  } catch (e) {
                    console.error('Error adding pending ICE candidate:', e);
                  }
                }
                pc.pendingIceCandidates = [];
              }
            }
            } catch (sdpError) {
              console.error('Error handling SDP:', sdpError);
            }
          }
          
          if (msg.ice) {
            try {
              if (pc.remoteDescription) {
                await pc.addIceCandidate(new RTCIceCandidate(msg.ice));
                console.log('ICE candidate added');
              } else {
                console.log('Waiting for remote description before adding ICE candidate');
                // Ø­ÙØ¸ ICE candidate Ù…Ø¤Ù‚ØªØ§Ù‹
                if (!pc.pendingIceCandidates) {
                  pc.pendingIceCandidates = [];
                }
                pc.pendingIceCandidates.push(new RTCIceCandidate(msg.ice));
              }
            } catch (error) {
              console.error('Error adding ICE candidate:', error);
            }
          }
        } catch (error) {
          console.error('Error handling signal:', error);
        }
      });

      // Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù„ØºØ±ÙØ©
      socket.emit('join-room', { bookingId });
      
    } catch (error) {
      console.error('Error accessing media devices:', error);
      const loadingEl = document.getElementById('loading');
      loadingEl.textContent = 'Ø®Ø·Ø£: ' + error.message;
      loadingEl.style.color = '#ff4444';
      
      // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ù…ÙØµÙ„Ø©
      const errorDetails = getErrorMessage(error);
      const userMessage = errorDetails + '\n\n' +
        'Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©:\n' +
        '1. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§/Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù…Ø© Ù…Ù† ØªØ·Ø¨ÙŠÙ‚ Ø¢Ø®Ø±\n' +
        '2. Ø£Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n' +
        '3. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§/Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªØµÙØ­\n' +
        '4. Ø¬Ø±Ø¨ Ù…ØªØµÙØ­ Ø¢Ø®Ø±';
      
      if (confirm(userMessage + '\n\nÙ‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ø¯ÙˆÙ† ÙƒØ§Ù…ÙŠØ±Ø§ØŸ')) {
        // Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ø¯ÙˆÙ† ÙƒØ§Ù…ÙŠØ±Ø§ (audio only Ø£Ùˆ Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø´ÙŠØ¡)
        localVideo.style.display = 'none';
        document.getElementById('loading').textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¯ÙˆÙ† ÙƒØ§Ù…ÙŠØ±Ø§...';
        // Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„
      } else {
        window.location.href = 'index.html';
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ ÙˆØ§Ø¶Ø­Ø©
    function getErrorMessage(error) {
      if (error.name === 'NotReadableError') {
        return 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§/Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† Ù…Ø³ØªØ®Ø¯Ù…Ø© Ù…Ù† ØªØ·Ø¨ÙŠÙ‚ Ø¢Ø®Ø±. Ø£ØºÙ„Ù‚Ù‡ ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
      } else if (error.name === 'NotAllowedError') {
        return 'ØªÙ… Ø±ÙØ¶ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§/Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªØµÙØ­.';
      } else if (error.name === 'NotFoundError') {
        return 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒØ§Ù…ÙŠØ±Ø§/Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†. ØªØ£ÙƒØ¯ Ù…Ù† ØªÙˆØµÙŠÙ„ Ø§Ù„Ø¬Ù‡Ø§Ø².';
      } else if (error.name === 'OverconstrainedError') {
        return 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„Ø§ ØªØ¯Ø¹Ù… Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©.';
      } else {
        return error.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§/Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†.';
      }
    }

    // Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    try {
      const response = await fetch(`${API_URL}/bookings/me`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      if (response.ok) {
        const bookings = await response.json();
        const booking = bookings.find(b => b.id === bookingId);
        if (booking) {
          document.getElementById('userBadge').textContent = 
            `Booking: ${bookingId.substring(0, 8)}... | Status: ${booking.status}`;
        }
      }
    } catch (e) {
      console.error('Failed to load booking info:', e);
    }
  })();
  </script>
</body>
</html>
